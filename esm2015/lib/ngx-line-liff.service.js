import { Inject, Injectable } from '@angular/core';
import { AsyncSubject, ReplaySubject } from 'rxjs';
import * as i0 from "@angular/core";
export class NgxLineLiffService {
    constructor(config) {
        this.providers = new Map();
        this.autoLogin = false;
        this._user = null;
        this._authState = new ReplaySubject(1);
        /* Consider making this an enum comprising LOADING, LOADED, FAILED etc. */
        this.initialized = false;
        this._initState = new AsyncSubject();
        if (config instanceof Promise) {
            config.then(config => this.initialize(config));
        }
        else {
            this.initialize(config);
        }
    }
    /** An `Observable` that one can subscribe to get the current logged in user information */
    get authState() {
        return this._authState.asObservable();
    }
    /** An `Observable` to communicate the readiness of the service and associated login providers */
    get initState() {
        return this._initState.asObservable();
    }
    initialize(config) {
        this.autoLogin = (config.autoLogin !== undefined) ? config.autoLogin : false;
        const { onError = console.error } = config;
        config.providers.forEach(item => this.providers.set(item.id, item.provider));
        Promise.all(Array.from(this.providers.values()).map(provider => provider.initialize())).then((provide) => {
            if (this.autoLogin) {
                const loginStatusPromises = new Array();
                let loggedIn = false;
                this.providers.forEach((provider, key) => {
                    let promise = provider.getLoginStatus();
                    loginStatusPromises.push(promise);
                    promise.then((user) => {
                        this._user = user;
                        this._authState.next(user);
                        loggedIn = true;
                    }).catch(console.debug);
                });
                Promise.all(loginStatusPromises).catch(() => {
                    if (!loggedIn) {
                        this._user = null;
                        this._authState.next(null);
                    }
                });
            }
        }).catch(err => {
            onError(err);
        }).finally(() => {
            this.initialized = true;
            this._initState.next(this.initialized);
            this._initState.complete();
        });
    }
    getLoginStatus() {
        return new Promise((resolve, reject) => {
            if (!this.initialized) {
                reject(NgxLineLiffService.ERR_NOT_INITIALIZED);
            }
            else {
                const providerObj = this.providers.get('LINE');
                if (providerObj) {
                    providerObj.getLoginStatus().then(user => {
                        this._user = user;
                        this._authState.next(user);
                        resolve(user);
                    }, err => reject(err)).catch(err => reject(err));
                }
                else {
                    reject(NgxLineLiffService.ERR_LOGIN_PROVIDER_NOT_FOUND);
                }
            }
        });
    }
    /**
     * A method used to sign in a user with a specific `LoginProvider`.
     * @param signInOption Optional `LoginProvider` specific arguments
     * @returns A `Promise` that resolves to the authenticated user information
     */
    signIn(signInOption) {
        return new Promise((resolve, reject) => {
            if (!this.initialized) {
                reject(NgxLineLiffService.ERR_NOT_INITIALIZED);
            }
            else {
                let providerObj = this.providers.get('LINE');
                if (providerObj) {
                    providerObj.signIn(signInOption).then((user) => {
                        this._user = user;
                        this._authState.next(user);
                        resolve(user);
                    }).catch(err => reject(err));
                }
                else {
                    reject(NgxLineLiffService.ERR_LOGIN_PROVIDER_NOT_FOUND);
                }
            }
        });
    }
    /**
     * A method used to sign out the currently loggen in user.
     * @returns A `Promise` that resolves if the operation is successful, rejects otherwise
     */
    signOut() {
        return new Promise((resolve, reject) => {
            if (!this.initialized) {
                reject(NgxLineLiffService.ERR_NOT_INITIALIZED);
            }
            else if (!this._user) {
                reject(NgxLineLiffService.ERR_NOT_LOGGED_IN);
            }
            else {
                const providerObj = this.providers.get('LINE');
                if (providerObj) {
                    providerObj.signOut().then(() => {
                        resolve();
                        this._user = null;
                        this._authState.next(null);
                    }).catch(err => reject(err));
                }
                else {
                    reject(NgxLineLiffService.ERR_LOGIN_PROVIDER_NOT_FOUND);
                }
            }
        });
    }
    /**
     * A method used to get provider core.
     * @returns A `Promise` that resolves to the provider core
     */
    providerCore() {
        return new Promise((resolve, reject) => {
            if (!this.initialized) {
                reject(NgxLineLiffService.ERR_NOT_INITIALIZED);
            }
            else if (!this._user) {
                reject(NgxLineLiffService.ERR_NOT_LOGGED_IN);
            }
            else {
                const providerObj = this.providers.get('LINE');
                if (providerObj) {
                    providerObj.providerCore().then(providerCore => resolve(providerCore)).catch(err => reject(err));
                }
                else {
                    reject(NgxLineLiffService.ERR_LOGIN_PROVIDER_NOT_FOUND);
                }
            }
        });
    }
}
NgxLineLiffService.ERR_LOGIN_PROVIDER_NOT_FOUND = 'Login provider not found';
NgxLineLiffService.ERR_NOT_LOGGED_IN = 'Not logged in';
NgxLineLiffService.ERR_NOT_INITIALIZED = 'Login providers not ready yet. Are there errors on your console?';
NgxLineLiffService.ERR_NOT_SUPPORTED_FOR_REFRESH_TOKEN = 'Chosen login provider is not supported for refreshing a token';
NgxLineLiffService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0, type: NgxLineLiffService, deps: [{ token: 'LineLiffServiceConfig' }], target: i0.ɵɵFactoryTarget.Injectable });
NgxLineLiffService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0, type: NgxLineLiffService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0, type: NgxLineLiffService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: ['LineLiffServiceConfig']
                }] }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LWxpbmUtbGlmZi5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vcHJvamVjdHMvbmd4LWxpbmUtbGlmZi9zcmMvbGliL25neC1saW5lLWxpZmYuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsTUFBTSxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNuRCxPQUFPLEVBQUUsWUFBWSxFQUFjLGFBQWEsRUFBRSxNQUFNLE1BQU0sQ0FBQzs7QUFjL0QsTUFBTSxPQUFPLGtCQUFrQjtJQXdCM0IsWUFDcUMsTUFBOEQ7UUFuQjNGLGNBQVMsR0FBK0IsSUFBSSxHQUFHLEVBQUUsQ0FBQztRQUNsRCxjQUFTLEdBQUcsS0FBSyxDQUFDO1FBRWxCLFVBQUssR0FBdUIsSUFBSSxDQUFDO1FBQ2pDLGVBQVUsR0FBc0MsSUFBSSxhQUFhLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFFN0UsMEVBQTBFO1FBQ2xFLGdCQUFXLEdBQUcsS0FBSyxDQUFDO1FBQ3BCLGVBQVUsR0FBMEIsSUFBSSxZQUFZLEVBQUUsQ0FBQztRQWEzRCxJQUFJLE1BQU0sWUFBWSxPQUFPLEVBQUU7WUFDM0IsTUFBTSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztTQUNsRDthQUFNO1lBQ0gsSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQztTQUMzQjtJQUNMLENBQUM7SUFqQkQsMkZBQTJGO0lBQzNGLElBQVcsU0FBUztRQUNoQixPQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsWUFBWSxFQUFFLENBQUM7SUFDMUMsQ0FBQztJQUNELGlHQUFpRztJQUNqRyxJQUFXLFNBQVM7UUFDaEIsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDLFlBQVksRUFBRSxDQUFDO0lBQzFDLENBQUM7SUFZTyxVQUFVLENBQUMsTUFB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QUFFO2dCQUNuQixNQUFNLENBQUMsa0JBQWtCLENBQUMsbUJBQW1CLENBQUMsQ0FBQzthQUNsRDtpQkFBTSxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRTtnQkFDcEIsTUFBTSxDQUFDLGtCQUFrQixDQUFDLGlCQUFpQixDQUFDLENBQUM7YUFDaEQ7aUJBQU07Z0JBQ0gsTUFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUM7Z0JBQy9DLElBQUksV0FBVyxFQUFFO29CQUNiLFdBQVcsQ0FBQyxZQUFZLEVBQUUsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztpQkFDcEc7cUJBQU07b0JBQ0gsTUFBTSxDQUFDLGtCQUFrQixDQUFDLDRCQUE0QixDQUFDLENBQUM7aUJBQzNEO2FBQ0o7UUFDTCxDQUFDLENBQUMsQ0FBQztJQUNQLENBQUM7O0FBM0p1QiwrQ0FBNEIsR0FBRywwQkFBMEIsQ0FBQztBQUMxRCxvQ0FBaUIsR0FBRyxlQUFlLENBQUM7QUFDcEMsc0NBQW1CLEdBQUcsa0VBQWtFLENBQUM7QUFDekYsc0RBQW1DLEdBQUcsK0RBQStELENBQUM7K0dBSnJILGtCQUFrQixrQkF5QmYsdUJBQXVCO21IQXpCMUIsa0JBQWtCOzJGQUFsQixrQkFBa0I7a0JBRDlCLFVBQVU7OzBCQTBCRixNQUFNOzJCQUFDLHVCQUF1QiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdCwgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQXN5bmNTdWJqZWN0LCBPYnNlcnZhYmxlLCBSZXBsYXlTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBMaW5lUHJvZmlsZSB9IGZyb20gJy4vZW50aXRpZXMvbGluZS1wcm9maWxlJztcbmltcG9ydCB7IExvZ2luUHJvdmlkZXIgfSBmcm9tICcuL2VudGl0aWVzL2xvZ2luLXByb3ZpZGVyJztcblxuLyoqXG4gKiBBbiBpbnRlcmZhY2UgdG8gZGVmaW5lIHRoZSBzaGFwZSBvZiB0aGUgc2VydmljZSBjb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTGluZUxpZmZTZXJ2aWNlQ29uZmlnIHtcbiAgICBhdXRvTG9naW4/OiBib29sZWFuO1xuICAgIHByb3ZpZGVyczogeyBpZDogc3RyaW5nOyBwcm92aWRlcjogTG9naW5Qcm92aWRlciB9W107XG4gICAgb25FcnJvcj86IChlcnJvcjogYW55KSA9PiBhbnk7XG59XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBOZ3hMaW5lTGlmZlNlcnZpY2Uge1xuICAgIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IEVSUl9MT0dJTl9QUk9WSURFUl9OT1RfRk9VTkQgPSAnTG9naW4gcHJvdmlkZXIgbm90IGZvdW5kJztcbiAgICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBFUlJfTk9UX0xPR0dFRF9JTiA9ICdOb3QgbG9nZ2VkIGluJztcbiAgICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBFUlJfTk9UX0lOSVRJQUxJWkVEID0gJ0xvZ2luIHByb3ZpZGVycyBub3QgcmVhZHkgeWV0LiBBcmUgdGhlcmUgZXJyb3JzIG9uIHlvdXIgY29uc29sZT8nO1xuICAgIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IEVSUl9OT1RfU1VQUE9SVEVEX0ZPUl9SRUZSRVNIX1RPS0VOID0gJ0Nob3NlbiBsb2dpbiBwcm92aWRlciBpcyBub3Qgc3VwcG9ydGVkIGZvciByZWZyZXNoaW5nIGEgdG9rZW4nO1xuXG4gICAgcHJpdmF0ZSBwcm92aWRlcnM6IE1hcDxzdHJpbmcsIExvZ2luUHJvdmlkZXI+ID0gbmV3IE1hcCgpO1xuICAgIHByaXZhdGUgYXV0b0xvZ2luID0gZmFsc2U7XG5cbiAgICBwcml2YXRlIF91c2VyOiBMaW5lUHJvZmlsZSB8IG51bGwgPSBudWxsO1xuICAgIHByaXZhdGUgX2F1dGhTdGF0ZTogUmVwbGF5U3ViamVjdDxMaW5lUHJvZmlsZSB8IG51bGw+ID0gbmV3IFJlcGxheVN1YmplY3QoMSk7XG5cbiAgICAvKiBDb25zaWRlciBtYWtpbmcgdGhpcyBhbiBlbnVtIGNvbXByaXNpbmcgTE9BRElORywgTE9BREVELCBGQUlMRUQgZXRjLiAqL1xuICAgIHByaXZhdGUgaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICBwcml2YXRlIF9pbml0U3RhdGU6IEFzeW5jU3ViamVjdDxib29sZWFuPiA9IG5ldyBBc3luY1N1YmplY3QoKTtcbiAgICAvKiogQW4gYE9ic2VydmFibGVgIHRoYXQgb25lIGNhbiBzdWJzY3JpYmUgdG8gZ2V0IHRoZSBjdXJyZW50IGxvZ2dlZCBpbiB1c2VyIGluZm9ybWF0aW9uICovXG4gICAgcHVibGljIGdldCBhdXRoU3RhdGUoKTogT2JzZXJ2YWJsZTxMaW5lUHJvZmlsZSB8IG51bGw+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2F1dGhTdGF0ZS5hc09ic2VydmFibGUoKTtcbiAgICB9XG4gICAgLyoqIEFuIGBPYnNlcnZhYmxlYCB0byBjb21tdW5pY2F0ZSB0aGUgcmVhZGluZXNzIG9mIHRoZSBzZXJ2aWNlIGFuZCBhc3NvY2lhdGVkIGxvZ2luIHByb3ZpZGVycyAqL1xuICAgIHB1YmxpYyBnZXQgaW5pdFN0YXRlKCk6IE9ic2VydmFibGU8Ym9vbGVhbj4ge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5pdFN0YXRlLmFzT2JzZXJ2YWJsZSgpO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBASW5qZWN0KCdMaW5lTGlmZlNlcnZpY2VDb25maWcnKSBjb25maWc6IExpbmVMaWZmU2VydmljZUNvbmZpZyB8IFByb21pc2U8TGluZUxpZmZTZXJ2aWNlQ29uZmlnPlxuICAgICkge1xuICAgICAgICBpZiAoY29uZmlnIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgY29uZmlnLnRoZW4oY29uZmlnID0+IHRoaXMuaW5pdGlhbGl6ZShjb25maWcpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZShjb25maWcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBpbml0aWFsaXplKGNvbmZpZzogTGluZUxpZmZTZXJ2aWNlQ29uZmlnKSB7XG4gICAgICAgIHRoaXMuYXV0b0xvZ2luID0gKGNvbmZpZy5hdXRvTG9naW4gIT09IHVuZGVmaW5lZCkgPyBjb25maWcuYXV0b0xvZ2luIDogZmFsc2U7XG4gICAgICAgIGNvbnN0IHsgb25FcnJvciA9IGNvbnNvbGUuZXJyb3IgfSA9IGNvbmZpZztcblxuICAgICAgICBjb25maWcucHJvdmlkZXJzLmZvckVhY2goaXRlbSA9PiB0aGlzLnByb3ZpZGVycy5zZXQoaXRlbS5pZCwgaXRlbS5wcm92aWRlcikpO1xuXG4gICAgICAgIFByb21pc2UuYWxsKFxuICAgICAgICAgICAgQXJyYXkuZnJvbSh0aGlzLnByb3ZpZGVycy52YWx1ZXMoKSkubWFwKHByb3ZpZGVyID0+IHByb3ZpZGVyLmluaXRpYWxpemUoKSlcbiAgICAgICAgKS50aGVuKChwcm92aWRlOiBhbnkpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmF1dG9Mb2dpbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvZ2luU3RhdHVzUHJvbWlzZXM6IEFycmF5PGFueT4gPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgICAgICAgICBsZXQgbG9nZ2VkSW4gPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIHRoaXMucHJvdmlkZXJzLmZvckVhY2goKHByb3ZpZGVyOiBMb2dpblByb3ZpZGVyLCBrZXk6IHN0cmluZykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcHJvbWlzZSA9IHByb3ZpZGVyLmdldExvZ2luU3RhdHVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2luU3RhdHVzUHJvbWlzZXMucHVzaChwcm9taXNlKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS50aGVuKCh1c2VyOiBMaW5lUHJvZmlsZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdXNlciA9IHVzZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hdXRoU3RhdGUubmV4dCh1c2VyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlZEluID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goY29uc29sZS5kZWJ1Zyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgUHJvbWlzZS5hbGwobG9naW5TdGF0dXNQcm9taXNlcykuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWxvZ2dlZEluKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl91c2VyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2F1dGhTdGF0ZS5uZXh0KG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICBvbkVycm9yKGVycik7XG4gICAgICAgIH0pLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9pbml0U3RhdGUubmV4dCh0aGlzLmluaXRpYWxpemVkKTtcbiAgICAgICAgICAgIHRoaXMuX2luaXRTdGF0ZS5jb21wbGV0ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcHVibGljIGdldExvZ2luU3RhdHVzKCk6IFByb21pc2U8TGluZVByb2ZpbGU+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pbml0aWFsaXplZCkge1xuICAgICAgICAgICAgICAgIHJlamVjdChOZ3hMaW5lTGlmZlNlcnZpY2UuRVJSX05PVF9JTklUSUFMSVpFRCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyT2JqID0gdGhpcy5wcm92aWRlcnMuZ2V0KCdMSU5FJyk7XG4gICAgICAgICAgICAgICAgaWYgKHByb3ZpZGVyT2JqKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyT2JqLmdldExvZ2luU3RhdHVzKCkudGhlbih1c2VyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3VzZXIgPSB1c2VyO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYXV0aFN0YXRlLm5leHQodXNlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHVzZXIpO1xuICAgICAgICAgICAgICAgICAgICB9LCBlcnIgPT4gcmVqZWN0KGVycikpLmNhdGNoKGVyciA9PiByZWplY3QoZXJyKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KE5neExpbmVMaWZmU2VydmljZS5FUlJfTE9HSU5fUFJPVklERVJfTk9UX0ZPVU5EKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIG1ldGhvZCB1c2VkIHRvIHNpZ24gaW4gYSB1c2VyIHdpdGggYSBzcGVjaWZpYyBgTG9naW5Qcm92aWRlcmAuXG4gICAgICogQHBhcmFtIHNpZ25Jbk9wdGlvbiBPcHRpb25hbCBgTG9naW5Qcm92aWRlcmAgc3BlY2lmaWMgYXJndW1lbnRzXG4gICAgICogQHJldHVybnMgQSBgUHJvbWlzZWAgdGhhdCByZXNvbHZlcyB0byB0aGUgYXV0aGVudGljYXRlZCB1c2VyIGluZm9ybWF0aW9uXG4gICAgICovXG4gICAgcHVibGljIHNpZ25JbihzaWduSW5PcHRpb24/OiB7IHJlZGlyZWN0VXJpPzogc3RyaW5nIH0pOiBQcm9taXNlPExpbmVQcm9maWxlPiB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoTmd4TGluZUxpZmZTZXJ2aWNlLkVSUl9OT1RfSU5JVElBTElaRUQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgcHJvdmlkZXJPYmogPSB0aGlzLnByb3ZpZGVycy5nZXQoJ0xJTkUnKTtcbiAgICAgICAgICAgICAgICBpZiAocHJvdmlkZXJPYmopIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJPYmouc2lnbkluKHNpZ25Jbk9wdGlvbikudGhlbigodXNlcjogTGluZVByb2ZpbGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3VzZXIgPSB1c2VyO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYXV0aFN0YXRlLm5leHQodXNlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHVzZXIpO1xuICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaChlcnIgPT4gcmVqZWN0KGVycikpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChOZ3hMaW5lTGlmZlNlcnZpY2UuRVJSX0xPR0lOX1BST1ZJREVSX05PVF9GT1VORCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBtZXRob2QgdXNlZCB0byBzaWduIG91dCB0aGUgY3VycmVudGx5IGxvZ2dlbiBpbiB1c2VyLlxuICAgICAqIEByZXR1cm5zIEEgYFByb21pc2VgIHRoYXQgcmVzb2x2ZXMgaWYgdGhlIG9wZXJhdGlvbiBpcyBzdWNjZXNzZnVsLCByZWplY3RzIG90aGVyd2lzZVxuICAgICAqL1xuICAgIHB1YmxpYyBzaWduT3V0KCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KE5neExpbmVMaWZmU2VydmljZS5FUlJfTk9UX0lOSVRJQUxJWkVEKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX3VzZXIpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoTmd4TGluZUxpZmZTZXJ2aWNlLkVSUl9OT1RfTE9HR0VEX0lOKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvdmlkZXJPYmogPSB0aGlzLnByb3ZpZGVycy5nZXQoJ0xJTkUnKTtcbiAgICAgICAgICAgICAgICBpZiAocHJvdmlkZXJPYmopIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJPYmouc2lnbk91dCgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdXNlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hdXRoU3RhdGUubmV4dChudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goZXJyID0+IHJlamVjdChlcnIpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoTmd4TGluZUxpZmZTZXJ2aWNlLkVSUl9MT0dJTl9QUk9WSURFUl9OT1RfRk9VTkQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBtZXRob2QgdXNlZCB0byBnZXQgcHJvdmlkZXIgY29yZS5cbiAgICAgKiBAcmV0dXJucyBBIGBQcm9taXNlYCB0aGF0IHJlc29sdmVzIHRvIHRoZSBwcm92aWRlciBjb3JlXG4gICAgICovXG4gICAgcHVibGljIHByb3ZpZGVyQ29yZSgpOiBQcm9taXNlPGFueT4ge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KE5neExpbmVMaWZmU2VydmljZS5FUlJfTk9UX0lOSVRJQUxJWkVEKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX3VzZXIpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoTmd4TGluZUxpZmZTZXJ2aWNlLkVSUl9OT1RfTE9HR0VEX0lOKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvdmlkZXJPYmogPSB0aGlzLnByb3ZpZGVycy5nZXQoJ0xJTkUnKTtcbiAgICAgICAgICAgICAgICBpZiAocHJvdmlkZXJPYmopIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJPYmoucHJvdmlkZXJDb3JlKCkudGhlbihwcm92aWRlckNvcmUgPT4gcmVzb2x2ZShwcm92aWRlckNvcmUpKS5jYXRjaChlcnIgPT4gcmVqZWN0KGVycikpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChOZ3hMaW5lTGlmZlNlcnZpY2UuRVJSX0xPR0lOX1BST1ZJREVSX05PVF9GT1VORCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59Il19